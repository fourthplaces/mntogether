# Development Rules

## Test-Driven Development

Red, green, refactor. For every feature, bug fix, or GraphQL edge change:

1. **Red** — Write a failing test first. Run it, verify it fails for the right reason.
2. **Green** — Write the simplest code that makes it pass.
3. **Refactor** — Clean up while keeping tests green.

### Test through GraphQL only

Tests exercise the public API surface, not internal implementation details.

- Use `ctx.graphql()` client for mutations and queries
- Verify results via GraphQL response and model queries
- Mock external services via TestDependencies
- Never access the event bus directly in tests (`bus().send()`, `settle()`)

```rust
#[test_context(TestHarness)]
#[tokio::test]
async fn test_scrape_creates_snapshots(ctx: &TestHarness) {
    let client = ctx.graphql();

    // Arrange
    let domain = Domain::create(...).await?;

    // Act: through GraphQL
    let result = client.query_with_vars(
        "mutation { scrapeOrganization(...) }",
        vars
    ).await;

    // Assert: response + database state via models
    assert_eq!(result["status"], "completed");
    let snapshots = DomainSnapshot::find_by_domain(...).await?;
    assert_eq!(snapshots.len(), 1);
}
```

### Use models, not raw SQL in tests

```rust
// Good
let domain = Domain::find_by_id(id, pool).await?;

// Bad
sqlx::query!("SELECT * FROM domains WHERE id = $1", id)
```

### Coverage expectations

Every GraphQL mutation/query should test:
1. Happy path
2. Error cases (validation, not found, unauthorized)
3. Edge cases (boundary values, concurrent requests)
4. State verification via models
5. GraphQL response structure

### Test structure

- Place in `packages/server/tests/`
- Name files descriptively: `{feature}_tests.rs`
- Use `#[test_context(TestHarness)]`
- One focused assertion per test
- Run `cargo test` before committing
