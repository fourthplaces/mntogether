# TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD

## Test-Driven Development IS MANDATORY

### TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD

**RED → GREEN → REFACTOR**

## The Sacred TDD Process

For EVERY feature, bug fix, or change to API edges:

1. **RED** - Write a FAILING test FIRST
   - Test must FAIL before you write ANY implementation code
   - Run the test and verify it fails for the right reason
   - If test passes before implementation, you're testing the wrong thing

2. **GREEN** - Make the test pass with minimal code
   - Write the SIMPLEST code that makes the test pass
   - Don't over-engineer or add extra features
   - Just make it work

3. **REFACTOR** - Improve the code while keeping tests green
   - Clean up code smells
   - Extract duplications
   - Improve names and structure
   - Tests must still pass after each refactor

## ABSOLUTE HARD RULE: API EDGE TESTING ONLY

**NEVER EVER UNDER ANY CIRCUMSTANCES:**
- ❌ `test_harness.bus().send(event).await` - FORBIDDEN
- ❌ `harness.settle().await` - FORBIDDEN
- ❌ Direct event bus access in tests - FORBIDDEN
- ❌ Test internal implementation details - FORBIDDEN

**ALWAYS AND ONLY:**
- ✅ Test through Restate virtual object handlers and API endpoints
- ✅ Use the Restate test client
- ✅ Verify results via API response AND model queries
- ✅ Mock external services via TestDependencies

This is a VERY VERY VERY HARD RULE. No exceptions.

### ❌ ABSOLUTELY FORBIDDEN:
```rust
// DON'T DO THIS! EVER! NEVER! FORBIDDEN!
test_harness.bus().send(ListingEvent::...).await;
test_harness.settle().await;  // ALSO FORBIDDEN!

// These bypass the API layer and test internal implementation.
// Tests MUST go through the actual API surface that users call.
```

## Use Models, Not Raw SQL

**NEVER write raw SQL queries in tests**
**ALWAYS use model methods or helper functions**

### GOOD:
```rust
let domain = Domain::find_by_id(id, pool).await?;
let snapshots = DomainSnapshot::find_by_domain(domain_id, pool).await?;
Domain::approve(domain_id, admin_id, pool).await?;
```

### BAD:
```rust
// DON'T DO THIS!
sqlx::query!("SELECT * FROM domains WHERE id = $1", id)
sqlx::query!("UPDATE domains SET status = 'approved' WHERE id = $1", id)
```

## Test Coverage Requirements

Every API edge MUST test:

1. **Happy path** - Successful operation
2. **Error cases** - Validation failures, not found, unauthorized
3. **Edge cases** - Race conditions, concurrent requests, boundary values
4. **State verification** - Check database state after operations using models
5. **API response** - Verify correct status, message, data

## Test Location and Structure

- Place in `packages/server/tests/` directory
- Name files descriptively: `{feature}_tests.rs`
- Group related tests in same file
- Use TestHarness with `#[test_context(TestHarness)]`
- Clear test documentation

## The Iron Law

```
TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD

IF TEST IS NOT FAILING FIRST → YOU ARE DOING IT WRONG

TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD
```

## Non-Negotiable Rules

1. **NO CODE WITHOUT TESTS** - Write test first, see it fail, then implement
2. **NO BUS TESTING** - Test through API edges only
3. **NO RAW SQL** - Use models and helper functions
4. **NO DELETING TESTS** - Fix them, don't delete them
5. **NO SKIPPING REFACTOR** - Clean code after making tests pass
6. **RUN TESTS BEFORE COMMIT** - `cargo test` must pass
7. **ONE ASSERTION PER TEST** - Tests should be focused and clear

## Remember

The point of TDD is not just to have tests.
The point is to let tests DRIVE your design.

Write the test you WISH you had.
Then make it real.

**TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD TDD**
